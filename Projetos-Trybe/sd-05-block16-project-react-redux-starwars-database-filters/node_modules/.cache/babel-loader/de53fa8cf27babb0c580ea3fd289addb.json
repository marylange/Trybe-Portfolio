{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports[\"default\"] = instrument;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = void 0;\n\nvar _difference = _interopRequireDefault(require(\"lodash/difference\"));\n\nvar _union = _interopRequireDefault(require(\"lodash/union\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _symbolObservable = _interopRequireDefault(require(\"symbol-observable\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nexports.ActionTypes = ActionTypes;\nvar isChrome = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\n\nvar ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit, toExcludeFromTrace) {\n    if (!(0, _isPlainObject[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    var stack;\n\n    if (trace) {\n      var extraFrames = 0;\n\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit;\n\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || Error.stackTraceLimit > traceLimit) {\n          var frames = stack.split('\\n');\n\n          if (frames.length > traceLimit) {\n            stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nexports.ActionCreators = ActionCreators;\nvar INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nexports.INIT_ACTION = INIT_ACTION;\n\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = void 0;\n\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action, trace, traceLimit, toExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n        monitorState = _ref.monitorState,\n        actionsById = _ref.actionsById,\n        nextActionId = _ref.nextActionId,\n        stagedActionIds = _ref.stagedActionIds,\n        skippedActionIds = _ref.skippedActionIds,\n        committedState = _ref.committedState,\n        currentStateIndex = _ref.currentStateIndex,\n        computedStates = _ref.computedStates,\n        isLocked = _ref.isLocked,\n        isPaused = _ref.isPaused;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _objectSpread({}, actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(shouldInit) {\n      var computedState;\n\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n\n        stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n        nextActionId++;\n      }\n\n      return {\n        monitorState: monitorState,\n        actionsById: _objectSpread(_objectSpread({}, actionsById), {}, _defineProperty({}, nextActionId - 1, liftAction({\n          type: options.pauseActionType\n        }))),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(_toConsumableArray(computedStates.slice(0, stagedActionIds.length - 1)), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [actionId]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId);\n\n            if (index === -1) {\n              skippedActionIds = [_actionId].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId);\n            break;\n          }\n\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = (0, _difference[\"default\"])(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union[\"default\"])(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference[\"default\"])(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId2 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId2); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n\n            var diff = idx - newIdx;\n\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, newIdx)), [_actionId2], _toConsumableArray(stagedActionIds.slice(newIdx, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1)));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1, newIdx)), [_actionId2], _toConsumableArray(stagedActionIds.slice(newIdx)));\n              minInvalidatedStateIndex = idx;\n            }\n\n            break;\n          }\n\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (Array.isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n\n            break;\n          }\n\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\n\n\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var lastDefinedState;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n\n    return lastDefinedState;\n  }\n\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return _objectSpread(_objectSpread({}, liftedStore), {}, _defineProperty({\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _symbolObservable[\"default\"], function () {\n    return _objectSpread(_objectSpread({}, liftedStore[_symbolObservable[\"default\"]]()), {}, {\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    });\n  }));\n}\n/**\n * Redux instrumentation store enhancer.\n */\n\n\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r[\"default\"] === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n\n          throw new Error('Expected the reducer to be a function.');\n        }\n\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n\n      var liftedStore = createStore(liftReducer(reducer), enhancer);\n\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}","map":{"version":3,"sources":["/Users/marylangeleal/Trybe-portfolio/sd-05-block16-project-react-redux-starwars-database-filters/node_modules/redux-devtools-instrument/lib/instrument.js"],"names":["Object","defineProperty","exports","value","liftAction","liftReducerWith","unliftState","unliftStore","instrument","INIT_ACTION","ActionCreators","ActionTypes","_difference","_interopRequireDefault","require","_union","_isPlainObject","_symbolObservable","obj","__esModule","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_typeof","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","chrome","process","type","isChromeOrNode","release","performAction","action","trace","traceLimit","toExcludeFromTrace","Error","stack","extraFrames","error","prevStackTraceLimit","captureStackTrace","stackTraceLimit","frames","split","startsWith","join","timestamp","Date","now","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","start","end","active","undefined","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","computeWithTryCatch","reducer","state","nextState","nextError","err","setTimeout","console","computeNextEntry","shouldCatchErrors","recomputeStates","computedStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","nextComputedStates","previousEntry","previousState","shouldSkip","indexOf","entry","initialCommittedState","monitorReducer","options","initialLiftedState","monitorState","nextActionId","currentStateIndex","isLocked","shouldStartLocked","isPaused","shouldRecordChanges","liftedState","liftedAction","_ref","commitExcessActions","excess","idsToDelete","concat","computePausedAction","shouldInit","computedState","pauseActionType","maxAge","shouldHotReload","Infinity","_actionId","actionIds","_index","Math","min","_actionId2","idx","newIdx","count","diff","preloadedState","shouldIncludeCallstack","_liftedAction$nextLif","liftedStore","liftReducer","lastDefinedState","getState","dispatch","replaceReducer","nextReducer","subscribe","observer","observeState","next","unsubscribe","createStore","initialState","enhancer","r"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports[\"default\"] = instrument;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = void 0;\n\nvar _difference = _interopRequireDefault(require(\"lodash/difference\"));\n\nvar _union = _interopRequireDefault(require(\"lodash/union\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _symbolObservable = _interopRequireDefault(require(\"symbol-observable\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nexports.ActionTypes = ActionTypes;\nvar isChrome = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\n\nvar ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit, toExcludeFromTrace) {\n    if (!(0, _isPlainObject[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    var stack;\n\n    if (trace) {\n      var extraFrames = 0;\n\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit;\n\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || Error.stackTraceLimit > traceLimit) {\n          var frames = stack.split('\\n');\n\n          if (frames.length > traceLimit) {\n            stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nexports.ActionCreators = ActionCreators;\nvar INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nexports.INIT_ACTION = INIT_ACTION;\n\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = void 0;\n\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action, trace, traceLimit, toExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n        monitorState = _ref.monitorState,\n        actionsById = _ref.actionsById,\n        nextActionId = _ref.nextActionId,\n        stagedActionIds = _ref.stagedActionIds,\n        skippedActionIds = _ref.skippedActionIds,\n        committedState = _ref.committedState,\n        currentStateIndex = _ref.currentStateIndex,\n        computedStates = _ref.computedStates,\n        isLocked = _ref.isLocked,\n        isPaused = _ref.isPaused;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _objectSpread({}, actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(shouldInit) {\n      var computedState;\n\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n\n        stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n        nextActionId++;\n      }\n\n      return {\n        monitorState: monitorState,\n        actionsById: _objectSpread(_objectSpread({}, actionsById), {}, _defineProperty({}, nextActionId - 1, liftAction({\n          type: options.pauseActionType\n        }))),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(_toConsumableArray(computedStates.slice(0, stagedActionIds.length - 1)), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [actionId]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId);\n\n            if (index === -1) {\n              skippedActionIds = [_actionId].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId);\n            break;\n          }\n\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = (0, _difference[\"default\"])(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union[\"default\"])(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference[\"default\"])(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId2 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId2); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n\n            var diff = idx - newIdx;\n\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, newIdx)), [_actionId2], _toConsumableArray(stagedActionIds.slice(newIdx, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1)));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1, newIdx)), [_actionId2], _toConsumableArray(stagedActionIds.slice(newIdx)));\n              minInvalidatedStateIndex = idx;\n            }\n\n            break;\n          }\n\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (Array.isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n\n            break;\n          }\n\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\n\n\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var lastDefinedState;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n\n    return lastDefinedState;\n  }\n\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return _objectSpread(_objectSpread({}, liftedStore), {}, _defineProperty({\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _symbolObservable[\"default\"], function () {\n    return _objectSpread(_objectSpread({}, liftedStore[_symbolObservable[\"default\"]]()), {}, {\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    });\n  }));\n}\n/**\n * Redux instrumentation store enhancer.\n */\n\n\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r[\"default\"] === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n\n          throw new Error('Expected the reducer to be a function.');\n        }\n\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n\n      var liftedStore = createStore(liftReducer(reducer), enhancer);\n\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}